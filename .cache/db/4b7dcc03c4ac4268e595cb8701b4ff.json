{"id":"heatmap_demo.html","dependencies":[],"generated":{"html":"<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n\t<meta charset=\"UTF-8\">\r\n\t<title>Title</title>\r\n</head>\r\n<body>\r\n<script type=\"x-shader/x-vertex\" id=\"vertexshader\">\r\n\t#ifdef GL_ES\r\n    precision highp float;\r\n    #endif\r\n    varying vec2 vUv;\r\n    void main() {\r\n \r\n\t  // uv 和 顶点变换\r\n      vUv = uv;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n \r\n    }\r\n \r\n  </script>\r\n \r\n<script type=\"x-shader/x-fragment\" id=\"fragmentshader\">\r\n \r\n    #ifdef GL_ES\r\n    precision highp float;\r\n    #endif\r\n    varying vec2 vUv;\r\n    uniform sampler2D alphaScaleMap;\r\n    uniform sampler2D paletteMap;\r\n \r\n    void main() {\r\n      // 温度转为权重alpha 并且 createRadialGradient 渐变的图\r\n      vec4 alphaColor = texture2D(alphaScaleMap, vUv);\r\n \r\n\t  // 根据温度转换为的权重alpha，确定改点的颜色 ，paletteMap 指定颜色条形图\r\n      vec4 color = texture2D(paletteMap, vec2(alphaColor.a, 0.0));\r\n      gl_FragColor = vec4(color.r, color.g, color.b, 1.0);\r\n    }\r\n \r\n  </script>\r\n<script type=\"importmap\">\r\n\t\t\t{\r\n\t\t\t\t\"imports\": {\r\n\t\t\t\t\t\"three\": \"../modules/three.module.js\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n</script>\r\n \r\n<script type=\"module\">\r\n \r\n\timport * as THREE from '../modules/three.module.js';\r\n\timport { OrbitControls } from '../modules/controls/OrbitControls.js';\r\n \r\n\tlet renderer, scene, camera;\r\n \r\n\tconst segments = 45;\r\n\tconst w = 256;\r\n\tconst h = 256;\r\n \r\n\t// 随机给出温度值 储存在2维数组\r\n\tconst getTemperature = () => {\r\n\t\tconst temperatureArray = new Array();\r\n\t\tfor ( let i = 0; i < segments; i ++ ) {\r\n\t\t\ttemperatureArray[ i ] = parseInt( Math.random() * 25 + 10 );  // 颜色的变化区间 10 - 35\r\n\t\t}\r\n \r\n\t\treturn temperatureArray;\r\n \r\n\t};\r\n \r\n\t// 绘制辐射圆\r\n\tconst drawCircular = ( context, opts ) => {\r\n \r\n\t\tvar { x, y, radius, weight } = opts;\r\n \r\n\t\tradius = parseInt( radius * weight );\r\n \r\n\t\t// 创建圆设置填充色\r\n\t\tconst rGradient = context.createRadialGradient( x, y, 0, x, y, radius );\r\n\t\trGradient.addColorStop( 0, 'rgba(255, 0, 0, 1)' );\r\n\t\trGradient.addColorStop( 1, 'rgba(0, 255, 0, 0)' );\r\n\t\tcontext.fillStyle = rGradient;\r\n \r\n\t\t// 设置globalAlpha\r\n\t\tcontext.globalAlpha = weight;\r\n\t\tcontext.beginPath();\r\n\t\tcontext.arc( x, y, radius, 0, 2 * Math.PI );\r\n\t\tcontext.closePath();\r\n \r\n\t\tcontext.fill();\r\n \r\n\t};\r\n \r\n\t// 获得渐变颜色条图\r\n\tconst getPaletteMap = () => {\r\n \r\n\t\t//颜色条的颜色分布\r\n\t\tconst colorStops = {\r\n\t\t\t1.0: '#f00',\r\n\t\t\t0.8: '#e2fa00',\r\n\t\t\t0.6: '#33f900',\r\n\t\t\t0.3: '#0349df',\r\n\t\t\t0.0: '#0f00ff'\r\n\t\t};\r\n \r\n\t\t//颜色条的大小\r\n\t\tconst width = 256, height = 10;\r\n \r\n\t\t// 创建canvas\r\n\t\tconst paletteCanvas = document.createElement( 'canvas' );\r\n\t\tpaletteCanvas.width = width;\r\n\t\tpaletteCanvas.height = height;\r\n\t\tpaletteCanvas.style.position = 'absolute';\r\n\t\tpaletteCanvas.style.top = '20px';\r\n\t\tpaletteCanvas.style.right = '10px';\r\n\t\tconst ctx = paletteCanvas.getContext( '2d' );\r\n \r\n\t\t// 创建线性渐变色\r\n\t\tconst linearGradient = ctx.createLinearGradient( 0, 0, width, 0 );\r\n\t\tfor ( const key in colorStops ) {\r\n \r\n\t\t\tlinearGradient.addColorStop( key, colorStops[ key ] );\r\n \r\n\t\t}\r\n \r\n\t\t// 绘制渐变色条\r\n\t\tctx.fillStyle = linearGradient;\r\n\t\tctx.fillRect( 0, 0, width, height );\r\n\t\tdocument.body.appendChild( paletteCanvas );\r\n\t\tconst paletteTexture = new THREE.Texture( paletteCanvas );\r\n\t\tpaletteTexture.minFilter = THREE.NearestFilter;\r\n\t\tpaletteTexture.needsUpdate = true;\r\n \r\n\t\treturn paletteTexture;\r\n \r\n\t};\r\n \r\n\t// 获取透明度阶梯图\r\n\tconst getAlphaScaleMap = ( width, height ) => {\r\n \r\n\t\tconst canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n \r\n\t\tconst context = canvas.getContext( '2d' );\r\n \r\n\t\t// 随机生成温度\r\n\t\tconst tenperature = getTemperature();\r\n \r\n\t\t// 绘制透明度阶梯图\r\n\t\tfor ( let i = 0; i < segments; i ++ ) {\r\n \r\n\t\t\t// 计算出当前温度占标准温度的权值\r\n\t\t\tconst weight = tenperature[ i ] / 25; // 25 是之前颜色的变化区间 10 - 35\r\n \r\n\t\t\tdrawCircular( context, {\r\n\t\t\t\tx: Math.random() * w,\r\n\t\t\t\ty: Math.random() * h,\r\n\t\t\t\tradius: 50,\r\n\t\t\t\tweight: weight\r\n \r\n\t\t\t} );\r\n \r\n\t\t}\r\n \r\n\t\t// 创建 Three 中的图片\r\n\t\tconst tex = new THREE.Texture( canvas );\r\n\t\ttex.minFilter = THREE.NearestFilter;\r\n\t\ttex.needsUpdate = true;\r\n\t\treturn tex;\r\n \r\n\t};\r\n \r\n\tinit();\r\n\tanimate();\r\n \r\n\t// 初始化\r\n\tfunction init() {\r\n \r\n\t\t// 渲染器\r\n\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\r\n\t\trenderer.setPixelRatio( window.devicePixelRatio );\r\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\r\n\t\trenderer.setClearColor( '#ccc' );\r\n\t\tdocument.body.appendChild( renderer.domElement );\r\n \r\n\t\t// 场景创建\r\n\t\tscene = new THREE.Scene();\r\n \r\n\t\t// camera 创建设置\r\n\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );\r\n\t\tcamera.position.set( 0, 0, 3000 );\r\n \r\n\t\tscene.add( new THREE.AmbientLight( 0xeef0ff ) );\r\n \r\n\t\t// 创建热力图渲染的平面几何体\r\n\t\tconst heatMapGeo = new THREE.PlaneBufferGeometry( 500, 500 );\r\n \r\n\t\t// 创建热力图渲染的材质\r\n\t\tconst heatMapMaterial = new THREE.ShaderMaterial( {\r\n\t\t\ttransparent: true,\r\n\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\r\n\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\r\n\t\t\tuniforms: {\r\n\t\t\t\t'alphaScaleMap': {\r\n\t\t\t\t\ttype: 't',\r\n\t\t\t\t\tvalue: getAlphaScaleMap( w, h )\r\n\t\t\t\t},\r\n\t\t\t\t'paletteMap': {\r\n\t\t\t\t\ttype: 't',\r\n\t\t\t\t\tvalue: getPaletteMap()\r\n\t\t\t\t},\r\n\t\t\t}\r\n \r\n\t\t} );\r\n \r\n\t\t// 创建热力图Mesh，并显示在 Plane 上\r\n\t\tconst heatMapPlane = new THREE.Mesh( heatMapGeo, heatMapMaterial );\r\n\t\tscene.add( heatMapPlane );\r\n\t\tconst contorl = new OrbitControls( camera, renderer.domElement );\r\n\t\twindow.addEventListener( 'resize', onWindowResize, false );\r\n \r\n\t}\r\n \r\n\t// 窗口变化的时候，进行 camera 视口的更新\r\n\tfunction onWindowResize() {\r\n \r\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\r\n\t\tcamera.updateProjectionMatrix();\r\n \r\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\r\n \r\n\t}\r\n \r\n\t// 动画 update\r\n\tfunction animate() {\r\n \r\n\t\trequestAnimationFrame( animate );\r\n\t\trenderer.render( scene, camera );\r\n \r\n\t}\r\n \r\n</script>\r\n</body>\r\n</html>"},"sourceMaps":null,"error":null,"hash":"dbf5cf8e08d0c1dea15c1c45bec5c5c5","cacheData":{}}